/*
CS 352 Prolog Project
By Philip Chiang, Karl Leano

Extra Features:
 + The program responds with the correct value of the property value if you enter
 a wrong one, e.g. "the color of the car is purple"
 + The program can parse sentences with more than one descriptor for
 property values, e.g. "the color of the rock is dark slate gray"
*/

%% Database is stored as a series of facts:
%% fact(object, property, [property_values])
fact(car, color, [blue]).

%% Executes the program. Generate a parse tree through the grammar s,
%% then continue to the executeIntermediate goal.
%% List: An instantiated list that represents the input sentence.
%% Ans: Non-instantiated variable that the response sentence will be bound to.
execute(List, Ans) :- s(ParseTree, List, []), executeIntermediate(ParseTree, Ans).

%% Beginning of the grammar

%% s is the start of the grammar.
%% It can branch to processing a statement or question.
s(s(STATEMENT)) --> stmt(STATEMENT).
s(s(QUESTION)) --> question(QUESTION).

%% Statement is made up of a phrase followed by preposition phrase and verb phrase
stmt(stmt(P, PREP_P, VP)) --> p(property, P), prep_p(PREP_P), vp(VP).

%% Question is made up of an interrogative phrase, then phrase, then preposition phrase
question(question(INTER_P, P, PREP_P)) --> inter_p(INTER_P), p(property, P), prep_p(PREP_P).

%% Phrase. It consists of either a determiner followed by a noun,
%% or just a noun.
%% Thing is the type of each noun in the phrase: object, property, or property_value
%%     It is helpful for generating the parse tree, where the value of Thing is
%%     associated next to the value of the noun.
p(Thing, p(DET,N)) --> det(DET), n(Thing, N).
p(Thing, p(N)) --> n(Thing, N).

%% Interrogative phrase: e.g. "what is". Consists of an interrogative determiner
%% followed by a verb.
inter_p(inter_p(INTER_DET, V)) --> inter_det(INTER_DET), v(V).

%% Interrogative Determiner: only value is "what".
inter_det(inter_det(what)) --> [what].

%% Preposition phrase e.g. "of the car". Consists of a preposition followed by a
%% phrase
prep_p(prep_p(PREP, P)) --> prep(PREP), p(object,P).

%% Verb phrase is a verb followed by a phrase.
vp(vp(V, P)) --> v(V), p(property_value, P).

%% Determiner can be either "the" or "a"
det(det(the)) --> [the].
det(det(a)) --> [a].

%% Verb, which can only be "is".
v(v(is)) --> [is].

%% Preposition, which can only be "of".
prep(prep(of)) --> [of].

%% Noun rules. There is a DCG for each type of noun.
%% Object - name of the object that is to bestored in the database. It is a
%% variable to keep possible values open ended and not hard coded
n(object, n(Obj)) --> [Obj].
%% Property - the property to be stored.
n(property, n(Prop)) --> [Prop].
%% Property Value - In this rule, the DCG is converted back to a regular rule
%% in order to instantiate PropVal, the value to pass back up the call chain,
%% to PropValList, which is a list of property values. This makes it possible to
%% have multiword property values.
n(property_value, n(PropVal), PropValList, _) :- PropVal = PropValList.

%% End of the grammar

%% Helper predicate. Negation as failure
neg(Goal) :- Goal,!,fail.
neg(_).

%% The executeIntermediate predicates are helpers for the execute predicate.
%% Tries out different goals based on the case.
%% ParseTree: parse tree generated by the s grammar.
%% Ans: Non-instantiated variable passed from the execute predicate.

%% This succeeds when the parse tree is a valid statement.
%% The first goal tries to instantiate ParseTree to the expected parse tree
%% of a stmt.
%% The second goal tries to execute the statement with the known values.
executeIntermediate(ParseTree, Ans) :-
    ParseTree = s(stmt(p(_, n(Property)), prep_p(_, p(_, n(Object))), vp(_, p(n(PropertyValue))))),
    executeStmt(Object, Property, PropertyValue, Ans), !.

%% This succeeds when the parse tree is a valid question.
%% The first goal tries to instantiate ParseTree to the expected parse tree
%% of a question.
%% The second goal tries to execute the question with the known values.
executeIntermediate(ParseTree, Ans) :-
    ParseTree = s(question(_, p(_, n(Property)), prep_p(_, p(_, n(Object))))),
    executeQuestion(Object, Property, Ans), !.

%% The user entered a question whose answer isn't in the knowledge base.
executeIntermediate(_, Ans) :- Ans = [i, dont, know], !.

%% The executeStmt predicates try to execute the statement, with different outcomes
%% for different cases.
%% Object: instantiated object name
%% Property: instantiated property name
%% PropertyValue: instantiated property value
%% Ans: uninstantiated variable for the reply

%% Case: fact is already in the database.
%% Reply with "I know".
executeStmt(Object, Property, PropertyValue, Ans) :-
    fact(Object, Property, PropertyValue),
    Ans = [i, know], !.

%% Case: a conflicting fact is in the database.
%% The first executeStmt predicate catches facts that are already
%%    in the database, so the first two goals take advantage of that to
%%    check that there is a object with the specified property, but
%%    they can't be unified.
executeStmt(Object, Property, PropertyValue, Ans) :-
    fact(Object, Property, ExistingPropertyValue),
    ExistingPropertyValue \= PropertyValue,
    append([no, it, is], ExistingPropertyValue, Ans), !.

%% Case: object is in the database, but user wants to define new property & property value.
%% First two goals find the object with existing properties that don't conflict with
%%    new property to add.
%% The third goal adds the new fact to the database.
executeStmt(Object, Property, PropertyValue, Ans) :-
    fact(Object, ExistingProperty, _),
    Property \= ExistingProperty,
    assert(fact(Object, Property, PropertyValue)),
    Ans = [ok], !.

%% Case: fact isn't in the database.
%% The first goal establishes that there is no fact concerning the object in the
%%     database.
%% The second goal adds the new fact to the database.
executeStmt(Object, Property, PropertyValue, Ans) :-
    not(fact(Object, _, _)),
    assert(fact(Object, Property, PropertyValue)),
    Ans = [ok], !.

%% Queries the database to see if there is an object with the specified property
%%    there, and returns the value.
%% Object: instantiated object name
%% Property: instantiated property name
%% Ans: uninstantiated variable for the reply
executeQuestion(Object, Property, Ans) :-
    fact(Object, Property, PropertyValue),
    append([it, is], PropertyValue, Ans), !.
